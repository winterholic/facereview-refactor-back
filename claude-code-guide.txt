==============================================================================
[FaceReview 프로젝트 코딩 가이드라인]
==============================================================================

0. .env파일은 읽지마 보안을 주의해줘

1. 아키텍처 원칙 (Layered Architecture)
------------------------------------------------------------------------------
(1) 라우터 (Router/Controller)
    - 위치: apps/routes/
    - 역할: HTTP 요청 파싱, Marshmallow 스키마 검증, Service 호출, 표준 응답 반환.
    - 금지: 비즈니스 로직 직접 작성 금지. DB 모델 직접 접근 금지. flask.views 사용 금지(간단한 프로젝트이므로 무조건 개별 메소드 선언)
    - 에러 처리: try-except로 에러를 직접 잡지 말고 common/utils/response_utils.py의 response_error 호출

(2) 서비스 (Service)
    - 위치: services/
    - 역할: 실제 비즈니스 로직, DB 트랜잭션 관리, 데이터 가공.
    - 금지: flask.jsonify() 등 HTTP 응답 객체 반환 최대한 지양. (순수 데이터만 반환)
    - 금지: 파이썬 내장 에러(ValueError 등) raise 금지, common/exception/exceptions.py의 BusinessError를 raise

(3) 데이터 접근 (Model/Schema)
    - 위치: models/, schemas/
    - schema로 들어오는 데이터 형식 최대한 검증
    - 데이터 처리도 model로 최대한 검증하여 사용
    - 그러나 데이터가 복잡하기 때문에 복잡한 데이터처리는 딕셔너리,리스트 사용 허용


2. 에러 핸들링 규칙
------------------------------------------------------------------------------
서비스 로직에서 예외 발생 시, 절대 Python 내장 에러를 던지지 않는다.

(1) 규칙
    - 무조건 `common.exception.BusinessError`를 raise 한다.
    - 인자로는 `common.error_code.APIError` Enum을 사용한다.
    - 필요 시 message 오버라이딩을 사용한다.

(2) Enum 관리 (중요)
    - 만약 현재 발생시켜야 할 에러가 `APIError` Enum에 없다면?
    - [행동강령]: 기존에 있는 것 중 대충 비슷한 걸 쓰지 말고,
      반드시 `common/error_code.py` 파일에 새로운 Enum 코드를 추가한 뒤 사용한다.

(3) 코드 예시
    [Bad - 절대 금지]
    if not user:
        raise ValueError("유저가 없습니다")

    [Good - 권장]
    # APIError.USER_NOT_FOUND가 없으면 먼저 정의하고 올 것.
    if not user:
        raise BusinessError(APIError.USER_NOT_FOUND)

    [Good - 메시지 변경]
    if password_retry > 5:
        raise BusinessError(APIError.AUTH_LOGIN_FAILED, "비밀번호 입력 횟수 초과")


3. 응답 포맷 (Standard Response)
------------------------------------------------------------------------------
모든 API 응답은 `utils.response` 모듈을 사용해 통일한다.

(1) 성공 시
    return response_success(data={...}, message="...")
    # 결과: {"result": "success", "message": "...", "data": {...}, "code": null}

(2) 실패 시
    # 전역 핸들러가 처리하므로 라우터에서 직접 호출할 일은 거의 없음
    # 결과: {"result": "fail", "message": "에러사유", "data": null, "code": "U001"}


4. 인증 및 컨텍스트 (Auth)
------------------------------------------------------------------------------
(1) 접근 제어 (Decorators)
    - API 성격에 따라 다음 3가지 중 하나를 반드시 명시한다.
    - @login_required: 토큰 필수. 토큰이 없거나 유효하지 않으면 즉시 에러 발생.
    - @login_optional: 토큰이 있으면 검증(로그인), 없으면 비로그인(Guest)으로 처리.
                       *주의: 토큰을 보냈으나 만료/위조된 경우엔 보안상 에러를 발생시킨다.
    - @public_route: 인증이 필요 없음을 명시적으로 표시 (회원가입, 로그인 등).

(2) 유저 정보 접근 (Global Context)
    - 데코레이터가 전처리 후 `flask.g` 객체에 상태를 주입한다.
    - g.user_id: 로그인 유저면 UUID, 비로그인(Guest)이면 None.
    - g.is_guest: 로그인 유저면 False, 비로그인(Guest)이면 True.
    - 라우터 로직 내에서 `if g.is_guest:` 또는 `if g.user_id:`로 분기 처리.

(3) 설정 값
    - JWT 비밀키 등 설정값은 `os.environ`을 직접 쓰지 말고,
      `flask.current_app.config.get('KEY')`를 통해 안전하게 접근.



5. 레디스 사용시 키 유의사항
------------------------------------------------------------------------------
다른 프로젝트들도 레디스를  사용하고 있으므로 가장 앞의 키에 facereview 붙이기